from medperf.exceptions import CleanExit, InvalidArgumentError, MedperfException
from medperf.utils import dict_pretty_print, approval_prompt
from medperf.entities.execution import Execution
from medperf import config
from medperf.account_management.account_management import get_medperf_user_data
from medperf.commands.execution.utils import filter_latest_executions


class ResultSubmission:
    @classmethod
    def run(cls, benchmark_uid, data_uid, model_uid, approved=False):
        sub = cls(benchmark_uid, data_uid, model_uid, approved=approved)
        sub.get_execution()
        sub.validate()
        sub.prepare()
        sub.update_execution()
        sub.write()

    def __init__(self, benchmark_uid, data_uid, model_uid, approved=False):
        self.benchmark_uid = benchmark_uid
        self.model_uid = model_uid
        self.data_uid = data_uid
        self.comms = config.comms
        self.ui = config.ui
        self.approved = approved

    def get_execution(self):
        owner = get_medperf_user_data()["id"]

        executions = Execution.all(filters={"owner": owner})
        executions = [
            execution
            for execution in executions
            if execution.benchmark == self.benchmark_uid
            and execution.model == self.model_uid
            and execution.dataset == self.data_uid
        ]
        if len(executions) == 0:
            raise InvalidArgumentError(
                "User has not created an execution"
                "for the specified benchmark, model, and dataset."
            )
        executions = filter_latest_executions(executions)
        if len(executions) != 1:
            raise MedperfException(
                "Internal error: one and only one execution should exist."
            )
        self.execution = executions[0]  # this should be only one value

    def validate(self):
        if not self.execution.is_executed():
            raise InvalidArgumentError("This execution is not mark as executed.")

        if self.execution.finalized:
            raise InvalidArgumentError(
                "Results of this execution were already uploaded."
            )

    def prepare(self):
        self.results = self.execution.read_results()
        self.partial = self.execution.is_partial()

    def request_approval(self):
        dict_pretty_print(self.results)
        self.ui.print("Above are the results generated by the model")

        approved = approval_prompt(
            "Do you approve uploading the presented results to MedPerf? [Y/n]"
        )

        return approved

    def update_execution(self):
        approved = self.approved or self.request_approval()

        if not approved:
            raise CleanExit("Results upload operation cancelled")

        uid = self.execution.id
        body = {
            "results": self.results,
            "metadata": {**self.execution.metadata, "partial": self.partial},
        }
        config.comms.update_execution(uid, body)

    def write(self):
        # this will do a .write with the new dictionary
        Execution.get(self.execution.id)
