from pathlib import Path
from medperf import config
from medperf.entities.cube import Cube
from medperf.entities.benchmark import Benchmark
from medperf.entities.ca import CA
from medperf.exceptions import CleanExit
from medperf.utils import (
    dict_pretty_print,
    approval_prompt,
    move_container_key_to_local_storage,
    get_model_owner_container_key_path
)
from medperf.commands.compatibility_test.run import CompatibilityTestExecution


class AssociateCube:
    @classmethod
    def run(
        cls,
        cube_uid: int,
        benchmark_uid: int,
        approved=False,
        no_cache=False,
    ):
        """Associates a cube with a given benchmark

        Args:
            cube_uid (int): UID of model MLCube
            benchmark_uid (int): UID of benchmark
            approved (bool): Skip validation step. Defualts to False
        """
        comms = config.comms
        ui = config.ui
        cube = Cube.get(cube_uid)
        benchmark = Benchmark.get(benchmark_uid)

        if cube.trusted_cas:
            ca = CA.get(cube.trusted_cas[0])  # TODO how to choose if more than 1?
            model_owner_key_path = get_model_owner_container_key_path(container_id=cube_uid, ca_name=ca.name)
        else:
            model_owner_key_path = None

        _, results = CompatibilityTestExecution.run(
            benchmark=benchmark_uid, model=cube_uid, no_cache=no_cache, decryption_key_path=model_owner_key_path
        )
        ui.print("These are the results generated by the compatibility test. ")
        ui.print("This will be sent along the association request.")
        ui.print("They will not be part of the benchmark.")
        dict_pretty_print(results)

        msg = "Please confirm that you would like to associate "
        msg += f"the model '{cube.name}' with the benchmark '{benchmark.name}' [Y/n]"
        approved = approved or approval_prompt(msg)
        if approved:
            ui.print("Generating model benchmark association")
            metadata = {"test_result": results}
            comms.associate_benchmark_model(cube_uid, benchmark_uid, metadata)
        else:
            raise CleanExit("Model association operation cancelled")


class AssociateCubeWithCAs:
    @classmethod
    def run(
        cls,
        cube_uid: int,
        ca_uids: list[int],
        decryption_key_path: Path,
        approved: bool = False,
    ):
        """Associates a cube with a given CA

        Args:
            cube_uid (int): UID of model MLCube
            ca_uid (int): UID of CA
            approved (bool): Skip validation step. Defualts to False
        """
        comms = config.comms
        cube = Cube.get(cube_uid)
        ca_ids_as_str = ', '.join(str(ca_uid) for ca_uid in ca_uids)
        msg = "Please confirm that you would like to associate "
        msg += f"the model '{cube.name}' (UID: {cube_uid}) with the Certificate Authorities (CAs) {ca_ids_as_str} [Y/n]"
        approved = approved or approval_prompt(msg)

        if not approved:
            raise CleanExit("Model association operation cancelled")

        valid_cas = set(cube.trusted_cas)
        ca_objects = CA.get_many(cube.trusted_cas)
        for ca in ca_objects:
            move_container_key_to_local_storage(cube_id=cube_uid, ca_name=ca.name, decryption_key_path=decryption_key_path)
            valid_cas.add(ca.id)

        updated_body = {
            'trusted_cas': sorted(list(valid_cas))
        }
        comms.update_mlcube(mlcube_id=cube_uid, mlcube_updated_body=updated_body)
